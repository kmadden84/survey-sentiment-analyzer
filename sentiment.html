<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Survey Data Comparator | Analytics Platform</title>
    <meta name="description" content="Professional survey data analysis and comparison tool with sentiment analysis, response distributions, and overlap visualization">
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Modern Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Heroicons for modern icons -->
    <script src="https://unpkg.com/heroicons@2.0.18/24/outline/index.js"></script>
    <!-- D3.js for Venn diagrams -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <!-- Venn.js for area-proportional Venn diagrams -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/venn.js/0.2.14/venn.min.js"></script>
    
    <script>
      tailwind.config = {
        darkMode: ['class', '[data-theme="dark"]'],
        theme: {
          extend: {
            fontFamily: {
              'sans': ['Inter', 'system-ui', 'sans-serif'],
            },
            colors: {
              primary: {
                50: '#eff6ff',
                100: '#dbeafe', 
                200: '#bfdbfe',
                300: '#93c5fd',
                400: '#60a5fa',
                500: '#3b82f6',
                600: '#2563eb',
                700: '#1d4ed8',
                800: '#1e40af',
                900: '#1e3a8a',
                950: '#172554',
              },
              // Split-complementary palette: Blue base with yellow-orange and red-orange (WCAG compliant)
              accent1: {
                50: '#fffbeb',
                100: '#fef3c7',
                200: '#fde68a',
                300: '#fcd34d',
                400: '#fbbf24',
                500: '#f59e0b',
                600: '#d97706',
                700: '#b45309',
                800: '#92400e',
                900: '#78350f',
                950: '#451a03', // Darker for better contrast
              },
              accent2: {
                50: '#fef2f2',
                100: '#fee2e2',
                200: '#fecaca',
                300: '#fca5a5',
                400: '#f87171',
                500: '#ef4444',
                600: '#dc2626',
                700: '#b91c1c',
                800: '#991b1b',
                900: '#7f1d1d',
                950: '#450a0a', // Darker for better contrast
              },
              surface: {
                50: '#f8fafc',
                100: '#f1f5f9', 
                200: '#e2e8f0',
                800: '#1e293b',
                900: '#0f172a',
                950: '#020617',
              },
              success: {
                500: '#10b981',
                600: '#059669',
              },
              warning: {
                500: '#f59e0b',
                600: '#d97706',
              },
              danger: {
                500: '#ef4444',
                600: '#dc2626',
              },
            },
            animation: {
              'slide-in-right': 'slideInRight 0.3s ease-out',
              'slide-in-left': 'slideInLeft 0.3s ease-out',
              'fade-in': 'fadeIn 0.2s ease-out',
              'bounce-subtle': 'bounceSubtle 2s infinite',
            },
            keyframes: {
              slideInRight: {
                '0%': { transform: 'translateX(100%)', opacity: '0' },
                '100%': { transform: 'translateX(0)', opacity: '1' },
              },
              slideInLeft: {
                '0%': { transform: 'translateX(-100%)', opacity: '0' },
                '100%': { transform: 'translateX(0)', opacity: '1' },
              },
              fadeIn: {
                '0%': { opacity: '0' },
                '100%': { opacity: '1' },
              },
              bounceSubtle: {
                '0%, 100%': { transform: 'translateY(0)' },
                '50%': { transform: 'translateY(-4px)' },
              },
            },
          }
        }
      }
    </script>
    
    <style>
      [data-theme="dark"] {
        color-scheme: dark;
      }
      
      /* Screen Reader and Skip Link Utilities */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      
      .skip-link {
        position: absolute;
        top: -40px;
        left: 6px;
        background: #2563eb;
        color: white;
        padding: 8px 16px;
        text-decoration: none;
        font-weight: 600;
        border-radius: 4px;
        z-index: 100;
        transition: top 0.3s;
      }
      
      .skip-link:focus {
        top: 6px;
      }
      
      /* Custom scrollbar */
      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: rgb(148 163 184 / 0.3);
      }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: rgb(148 163 184 / 0.5);
      }
      
      /* Question select dropdown - proper text handling */
      #question-select {
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }
      
      /* Dropdown options should show full text when opened */
      #question-select option {
        white-space: normal; /* Allow text wrapping in dropdown options */
        word-wrap: break-word;
        overflow: visible;
        padding: 8px 12px;
        line-height: 1.4;
        min-height: auto;
      }
      
      /* Mobile specific improvements */
      @media (max-width: 767px) {
        #question-select option {
          font-size: 14px;
          padding: 10px 12px;
          line-height: 1.4;
        }
      }
      
      /* Flat design transitions */
      * {
        transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      }
      
      /* Synchronized scrolling lists */
      .sync-scroll-container {
        overflow-y: auto;
        max-height: 300px;
        cursor: grab;
        user-select: none;
      }
      
      .sync-scroll-container:active {
        cursor: grabbing;
      }
      
      .sync-scroll-item {
        min-height: 60px;
        display: flex;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid #e2e8f0;
        pointer-events: none; /* Prevent text selection during drag */
      }
      
      .sync-scroll-container:not(.dragging) .sync-scroll-item {
        pointer-events: auto; /* Re-enable interactions when not dragging */
      }
      
      [data-theme="dark"] .sync-scroll-item {
        border-bottom-color: #374151;
      }
      
      /* Pure CSS horizontal scrolling - no JavaScript needed */
      .view-slider {
        display: flex;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      
      .view-slider::-webkit-scrollbar {
        display: none;
      }
      
      .view-slide {
        flex: 0 0 100%;
        scroll-snap-align: start;
        min-height: 400px;
      }
      
      /* CSS-only navigation with scroll-behavior */
      .view-slide {
        scroll-margin-left: 0;
      }
      
      /* Remove drag cursor since we're not using JS drag */
      .view-slider {
        cursor: default;
      }
      
      /* Disable scroll snapping during manual interaction */
      .view-slider.manual-scroll {
        scroll-snap-type: none;
      }
      
      /* Flat design - no glass morphism */
      .flat-card {
        background: #ffffff;
        border: 1px solid #e2e8f0;
      }
      
      [data-theme="dark"] .flat-card {
        background: #0f172a;
        border-color: #374151;
      }
      
      /* Hide default input styling */
      input[type="file"]::-webkit-file-upload-button {
        display: none;
      }
      
      /* Mobile-first responsive design helpers */
      .mobile-only { display: block; }
      .desktop-only { display: none; }
      
      @media (min-width: 768px) {
        .mobile-only { display: none; }
        .desktop-only { display: block; }
      }
      
      /* File status indicators with split-complementary colors (WCAG compliant) */
      .status-success {
        color: #059669;
      }
      
      .status-warning {
        color: #b45309; /* Darker orange for better contrast */
      }
      
      .status-error {
        color: #b91c1c; /* Darker red for better contrast */
      }
      
      [data-theme="dark"] .status-success {
        color: #10b981;
      }
      
      [data-theme="dark"] .status-warning {
        color: #fbbf24; /* Lighter orange for dark theme */
      }
      
      [data-theme="dark"] .status-error {
        color: #f87171; /* Lighter red for dark theme */
      }
    </style>
  </head>

<body class="font-sans antialiased bg-surface-50 dark:bg-surface-950 text-slate-900 dark:text-slate-100 min-h-screen">
  
  <!-- Skip Links for Screen Readers -->
  <div class="sr-only">
    <a href="#main-content" class="skip-link bg-primary-600 text-white px-4 py-2 absolute top-0 left-0 z-50 focus:not-sr-only focus:relative">Skip to main content</a>
    <a href="#upload-section" class="skip-link bg-primary-600 text-white px-4 py-2 absolute top-0 left-0 z-50 focus:not-sr-only focus:relative">Skip to data upload</a>
    <a href="#analysis-section" class="skip-link bg-primary-600 text-white px-4 py-2 absolute top-0 left-0 z-50 focus:not-sr-only focus:relative">Skip to analysis</a>
  </div>
  
  <!-- Navigation Header -->
  <header class="sticky top-0 z-50 bg-white dark:bg-surface-900 border-b border-surface-200 dark:border-surface-700" role="banner">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex items-center justify-between h-16">
        
        <!-- Logo and Title -->
        <div class="flex items-center space-x-3">
          <div class="w-8 h-8 bg-primary-500 flex items-center justify-center" aria-hidden="true">
            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
          </div>
          <div>
            <h1 class="text-xl font-bold text-slate-900 dark:text-white">Survey Comparator</h1>
            <p class="text-xs text-slate-500 dark:text-slate-400 hidden sm:block">Advanced Analytics Platform</p>
          </div>
        </div>

        <!-- Actions -->
        <nav class="flex items-center space-x-3" role="navigation" aria-label="Main navigation">
          
          <!-- Help Button -->
          <button id="help-btn" class="p-2 text-slate-600 dark:text-slate-400 hover:text-accent1-800 dark:hover:text-accent1-300 hover:bg-slate-100 dark:hover:bg-surface-800 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" aria-label="Open help and documentation" aria-describedby="help-tooltip">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <span class="sr-only">Help</span>
          </button>

          <!-- Theme Toggle -->
          <button id="theme-toggle" class="p-2 text-slate-600 dark:text-slate-400 hover:text-accent1-800 dark:hover:text-accent1-300 hover:bg-slate-100 dark:hover:bg-surface-800 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" aria-label="Toggle dark mode" aria-pressed="false">
            <svg id="theme-icon-light" class="w-5 h-5 block dark:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>
            </svg>
            <svg id="theme-icon-dark" class="w-5 h-5 hidden dark:block" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>
            </svg>
            <span class="sr-only">Toggle theme</span>
          </button>
        </nav>
      </div>
    </div>
  </header>

  <!-- Main Container with semantic structure -->
  <main id="main-content" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 space-y-6" role="main" aria-label="Survey comparison application">
    
    <!-- Data Upload Section -->
    <section id="upload-section" class="flat-card border border-surface-200 dark:border-surface-700 p-6" aria-labelledby="upload-heading">
      <header class="flex items-center justify-between mb-6">
        <div>
          <h2 id="upload-heading" class="text-lg font-semibold text-slate-900 dark:text-white">Data Upload</h2>
          <p class="text-sm text-slate-600 dark:text-slate-400">Upload your survey datasets in JSON format</p>
        </div>
        <div class="flex items-center space-x-2">
          <div id="upload-status" class="hidden" role="status" aria-live="polite" aria-atomic="true">
            <div class="flex items-center space-x-2 text-sm">
              <div class="w-2 h-2 bg-accent1-600 animate-pulse" aria-hidden="true"></div>
              <span class="text-accent1-800 dark:text-accent1-300">Processing...</span>
            </div>
          </div>
        </div>
      </header>

      <!-- File Upload Grid -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6" role="group" aria-labelledby="upload-heading">
        
        <!-- Dataset 1 Upload -->
        <fieldset class="space-y-3">
          <legend class="block text-sm font-medium text-slate-700 dark:text-slate-300">
            Dataset A
            <span class="text-xs text-slate-500 dark:text-slate-400 font-normal ml-1">(Primary)</span>
          </legend>
          
          <div class="relative">
            <input 
              type="file" 
              id="file1" 
              accept=".json" 
              class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
              aria-describedby="file1-description"
            />
            <div class="flex items-center justify-center w-full h-32 border-2 border-dashed border-slate-300 dark:border-slate-600 hover:border-primary-400 dark:hover:border-primary-400 transition-colors bg-slate-50 dark:bg-surface-800 hover:bg-primary-50 dark:hover:bg-primary-950">
              <div class="text-center">
                <svg class="mx-auto h-8 w-8 text-slate-400 dark:text-slate-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                </svg>
                <p class="text-sm text-slate-600 dark:text-slate-400">
                  <span class="font-medium text-primary-600 dark:text-primary-400">Click to upload</span>
                  <span class="block text-xs mt-1" id="file1-description">JSON files only</span>
                </p>
              </div>
            </div>
          </div>
          
          <div id="file1-info" class="hidden bg-slate-50 dark:bg-surface-800 p-3" role="status" aria-live="polite">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-2">
                <svg class="w-4 h-4 text-primary-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                </svg>
                <span id="file1-name" class="text-sm font-medium text-slate-700 dark:text-slate-300"></span>
              </div>
              <button id="file1-remove" class="text-slate-400 hover:text-accent2-500 transition-colors" aria-label="Remove uploaded file">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
            <div id="file1-status" class="mt-2 text-xs"></div>
          </div>
        </fieldset>

        <!-- Dataset 2 Upload -->
        <fieldset class="space-y-3">
          <legend class="block text-sm font-medium text-slate-700 dark:text-slate-300">
            Dataset B
            <span class="text-xs text-slate-500 dark:text-slate-400 font-normal ml-1">(Comparison)</span>
          </legend>
          
          <div class="relative">
            <input 
              type="file" 
              id="file2" 
              accept=".json" 
              class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
              aria-describedby="file2-description"
            />
            <div class="flex items-center justify-center w-full h-32 border-2 border-dashed border-slate-300 dark:border-slate-600 hover:border-primary-400 dark:hover:border-primary-400 transition-colors bg-slate-50 dark:bg-surface-800 hover:bg-primary-50 dark:hover:bg-primary-950">
              <div class="text-center">
                <svg class="mx-auto h-8 w-8 text-slate-400 dark:text-slate-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                </svg>
                <p class="text-sm text-slate-600 dark:text-slate-400">
                  <span class="font-medium text-primary-600 dark:text-primary-400">Click to upload</span>
                  <span class="block text-xs mt-1" id="file2-description">JSON files only</span>
                </p>
              </div>
            </div>
          </div>
          
          <div id="file2-info" class="hidden bg-slate-50 dark:bg-surface-800 p-3" role="status" aria-live="polite">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-2">
                <svg class="w-4 h-4 text-primary-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                </svg>
                <span id="file2-name" class="text-sm font-medium text-slate-700 dark:text-slate-300"></span>
              </div>
              <button id="file2-remove" class="text-slate-400 hover:text-accent2-500 transition-colors" aria-label="Remove uploaded file">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
            <div id="file2-status" class="mt-2 text-xs"></div>
          </div>
        </fieldset>
      </div>

      <!-- Question Selection -->
      <div class="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
        <label for="question-select" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">
          Compare Question
        </label>
        <select 
          id="question-select" 
          class="w-full px-3 py-2 bg-white dark:bg-surface-800 border border-slate-300 dark:border-slate-600 text-slate-900 dark:text-white focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-colors"
          disabled
          aria-describedby="question-help"
        >
          <option value="">Upload datasets to see available questions</option>
        </select>
        <p id="question-help" class="text-xs text-slate-500 dark:text-slate-400 mt-1">Select a question that appears in both datasets for comparison</p>
      </div>
    </section>

    <!-- Analysis Views -->
    <section id="analysis-section" class="relative overflow-hidden" aria-labelledby="analysis-heading">
      <h2 id="analysis-heading" class="sr-only">Data Analysis and Visualization</h2>
      
      <!-- View Navigation (Desktop) -->
      <nav class="desktop-only mb-6" role="tablist" aria-label="Analysis view navigation">
        <div class="flex space-x-1 bg-slate-100 dark:bg-surface-800 p-1 w-fit">
          <button data-view="responses" class="nav-tab px-4 py-2 text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" role="tab" aria-selected="true" aria-controls="responses-view" id="responses-tab">
            Responses
          </button>
          <button data-view="sentiment" class="nav-tab px-4 py-2 text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" role="tab" aria-selected="false" aria-controls="sentiment-view" id="sentiment-tab">
            Sentiment
          </button>
          <button data-view="overlap" class="nav-tab px-4 py-2 text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" role="tab" aria-selected="false" aria-controls="overlap-view" id="overlap-tab">
            Overlap
          </button>
        </div>
      </nav>

      <!-- Mobile Navigation -->
      <nav class="mobile-only mb-4" aria-label="Mobile analysis navigation">
        <!-- Current View Indicator with Navigation -->
        <div class="flex items-center justify-between mb-3 bg-white dark:bg-surface-900 p-3 border border-surface-200 dark:border-surface-700">
          <button id="mobile-prev" class="p-2 text-slate-400 hover:text-accent1-800 dark:hover:text-accent1-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" aria-label="Previous analysis view" disabled>
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>
          
          <div class="text-center flex-1 mx-3">
            <div class="text-sm font-medium text-slate-900 dark:text-white" id="current-view-title" aria-live="polite">Response Distributions</div>
            <div class="text-xs text-slate-500 dark:text-slate-400">Swipe or tap arrows</div>
          </div>
          
          <button id="mobile-next" class="p-2 text-slate-400 hover:text-accent1-800 dark:hover:text-accent1-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" aria-label="Next analysis view">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
        
        <!-- Mobile View Selector Dropdown -->
        <div class="mb-3">
          <label for="mobile-view-select" class="sr-only">Select analysis view</label>
          <select id="mobile-view-select" class="w-full px-3 py-2 bg-white dark:bg-surface-800 border border-slate-300 dark:border-slate-600 text-slate-900 dark:text-white focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-colors text-sm" aria-describedby="mobile-view-help">
            <option value="responses">📊 Response Distributions</option>
            <option value="sentiment">💭 Sentiment Analysis</option>
            <option value="overlap">🔄 Response Overlap</option>
          </select>
          <div id="mobile-view-help" class="sr-only">Use this dropdown to navigate between different analysis views</div>
        </div>
      </nav>

      <!-- View Container -->
      <div id="view-container" class="relative min-h-[400px] flat-card border border-surface-200 dark:border-surface-700 overflow-hidden" role="tabpanel" aria-live="polite" aria-atomic="false">
        
        <!-- Empty State -->
        <div id="empty-state" class="flex flex-col items-center justify-center h-96 text-center p-8" role="status" aria-live="polite">
          <div class="w-16 h-16 bg-slate-100 dark:bg-surface-800 flex items-center justify-center mb-4" aria-hidden="true">
            <svg class="w-8 h-8 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
          </div>
          <h3 class="text-lg font-medium text-slate-900 dark:text-white mb-2">No Data to Compare</h3>
          <p class="text-slate-600 dark:text-slate-400 max-w-sm">Upload your survey datasets above to start analyzing and comparing responses, sentiment scores, and data overlaps.</p>
        </div>

        <!-- Loading State -->
        <div id="loading-state" class="hidden flex flex-col items-center justify-center h-96 text-center p-8" role="status" aria-live="polite" aria-atomic="true">
          <div class="w-8 h-8 border-4 border-primary-200 border-t-primary-600 animate-spin mb-4" aria-hidden="true"></div>
          <h3 class="text-lg font-medium text-slate-900 dark:text-white mb-2">Processing Data</h3>
          <p class="text-slate-600 dark:text-slate-400">Analyzing and transforming your datasets...</p>
        </div>

        <!-- Slider Container -->
        <div id="view-slider" class="view-slider hidden" role="tabpanel" aria-label="Analysis views">
          <div id="responses-view" class="view-slide" role="tabpanel" aria-labelledby="responses-tab" tabindex="0">
            <!-- Responses content will be inserted here -->
          </div>
          <div id="sentiment-view" class="view-slide" role="tabpanel" aria-labelledby="sentiment-tab" tabindex="0">
            <!-- Sentiment content will be inserted here -->
          </div>
          <div id="overlap-view" class="view-slide" role="tabpanel" aria-labelledby="overlap-tab" tabindex="0">
            <!-- Overlap content will be inserted here -->
          </div>
        </div>

      </div>

      <!-- Mobile Navigation Dots -->
      <nav class="mobile-only flex justify-center space-x-2 mt-4" role="tablist" aria-label="View indicator dots">
        <button data-view="responses" class="nav-dot w-2 h-2 bg-slate-300 dark:bg-slate-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" role="tab" aria-label="Go to response distributions view" aria-selected="true"></button>
        <button data-view="sentiment" class="nav-dot w-2 h-2 bg-slate-300 dark:bg-slate-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" role="tab" aria-label="Go to sentiment analysis view" aria-selected="false"></button>
        <button data-view="overlap" class="nav-dot w-2 h-2 bg-slate-300 dark:bg-slate-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" role="tab" aria-label="Go to overlap analysis view" aria-selected="false"></button>
      </nav>
    </section>
  </main>

  <!-- Help Modal -->
  <div id="help-modal" class="hidden fixed inset-0 z-50 overflow-y-auto" role="dialog" aria-modal="true" aria-labelledby="help-modal-title" aria-describedby="help-modal-description">
    <div class="flex items-center justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
      <div class="fixed inset-0 bg-slate-500 bg-opacity-75 transition-opacity" aria-hidden="true"></div>

      <div class="inline-block align-bottom flat-card border border-surface-200 dark:border-surface-700 text-left overflow-hidden transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full" role="document">
        <div class="px-6 pt-6 pb-4">
          <div class="flex items-center justify-between">
            <h3 id="help-modal-title" class="text-lg font-medium text-slate-900 dark:text-white">Data Format Guide</h3>
            <button id="help-close" class="text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2" aria-label="Close help dialog">
              <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
            </button>
          </div>
        </div>
        
        <div id="help-modal-description" class="px-6 pb-6 space-y-4">
          <div>
            <h4 class="font-medium text-slate-900 dark:text-white mb-2">Expected JSON Format</h4>
            <pre class="bg-slate-100 dark:bg-surface-800 p-3 text-xs overflow-x-auto"><code>[
  {
    "id": "resp_001",
    "Question 1": "Answer text here",
    "Question 2": "Another answer",
    "sentiment_score": 0.75
  }
]</code></pre>
          </div>
          
          <div>
            <h4 class="font-medium text-slate-900 dark:text-white mb-2">Supported Formats</h4>
            <ul class="text-sm text-slate-600 dark:text-slate-400 space-y-1">
              <li>• <strong>Direct array:</strong> JSON array of response objects</li>
              <li>• <strong>Wrapped format:</strong> <code>{"responses": [...]}</code> or <code>{"data": [...]}</code></li>
              <li>• <strong>Question/Answer pairs:</strong> Automatically converted to direct properties</li>
            </ul>
          </div>
          
          <div>
            <h4 class="font-medium text-slate-900 dark:text-white mb-2">Sentiment Scores</h4>
            <ul class="text-sm text-slate-600 dark:text-slate-400 space-y-1">
              <li>• <strong>0-1 range:</strong> 0.0 (negative) to 1.0 (positive)</li>
              <li>• <strong>1-5 scale:</strong> Automatically converted</li>
              <li>• <strong>-1 to +1:</strong> Automatically converted</li>
              <li>• <strong>Text values:</strong> "positive", "negative", "neutral"</li>
            </ul>
          </div>
          
          <div class="bg-primary-50 dark:bg-primary-950 p-3">
            <p class="text-sm text-primary-700 dark:text-primary-300">
              <strong>Note:</strong> The app will automatically detect and convert different data formats. You'll see processing messages if any transformations are applied.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // State Management
    let state = {
      dataset1: null,
      dataset2: null,
      currentView: 'responses',
      selectedQuestion: null,
      dataFormatIssues: { dataset1: [], dataset2: [] },
      touchStart: null,
      isProcessing: false,
      dragStart: null,
      isDragging: false,
      scrollPosition: 0,
      initialScrollLeft: 0
    };

    // DOM Elements with robust error handling
    const elements = {
      // File inputs
      file1: document.getElementById('file1'),
      file2: document.getElementById('file2'),
      file1Info: document.getElementById('file1-info'),
      file2Info: document.getElementById('file2-info'),
      file1Name: document.getElementById('file1-name'),
      file2Name: document.getElementById('file2-name'),
      file1Status: document.getElementById('file1-status'),
      file2Status: document.getElementById('file2-status'),
      file1Remove: document.getElementById('file1-remove'),
      file2Remove: document.getElementById('file2-remove'),

      // Question selection
      questionSelect: document.getElementById('question-select'),

      // Navigation
      navTabs: document.querySelectorAll('.nav-tab'),
      navDots: document.querySelectorAll('.nav-dot'),
      mobileViewSelect: document.getElementById('mobile-view-select'),
      mobilePrev: document.getElementById('mobile-prev'),
      mobileNext: document.getElementById('mobile-next'),
      currentViewTitle: document.getElementById('current-view-title'),

      // Views
      viewContainer: document.getElementById('view-container'),
      viewSlider: document.getElementById('view-slider'),
      responsesView: document.getElementById('responses-view'),
      sentimentView: document.getElementById('sentiment-view'),
      overlapView: document.getElementById('overlap-view'),
      emptyState: document.getElementById('empty-state'),
      loadingState: document.getElementById('loading-state'),

      // Theme and help
      themeToggle: document.getElementById('theme-toggle'),
      helpBtn: document.getElementById('help-btn'),
      helpModal: document.getElementById('help-modal'),
      helpClose: document.getElementById('help-close'),

      // Status
      uploadStatus: document.getElementById('upload-status')
    };

    // Validate critical DOM elements exist
    const validateDOMElements = () => {
      const criticalElements = ['file1', 'file2', 'questionSelect', 'viewContainer'];
      const missingElements = criticalElements.filter(id => !elements[id]);
      
      if (missingElements.length > 0) {
        console.error('Critical DOM elements missing:', missingElements);
        throw new Error(`Missing critical elements: ${missingElements.join(', ')}`);
      }
    };

    // Enhanced Data Processing with modern JavaScript
    const validateAndTransformData = (rawData, filename) => {
      const issues = [];
      let transformedData = null;

      try {
        if (!rawData) {
          issues.push("No data provided");
          return { data: null, issues };
        }

        if (!Array.isArray(rawData)) {
          if (rawData?.responses && Array.isArray(rawData.responses)) {
            rawData = rawData.responses;
            issues.push("✓ Detected nested format - extracted 'responses' array");
          } else if (rawData?.data && Array.isArray(rawData.data)) {
            rawData = rawData.data;
            issues.push("✓ Detected nested format - extracted 'data' array");
          } else {
            issues.push("❌ Data must be an array of responses or contain 'responses'/'data' array");
            return { data: null, issues };
          }
        }

        if (rawData.length === 0) {
          issues.push("❌ Dataset is empty");
          return { data: null, issues };
        }

        const formatInfo = detectDataFormat(rawData);
        transformedData = normalizeDataFormat(rawData, formatInfo, issues);
        validateDataQuality(transformedData, issues);

        return { data: transformedData, issues };

      } catch (error) {
        console.error('Data validation error:', error);
        issues.push(`❌ Data processing error: ${error?.message || 'Unknown error'}`);
        return { data: null, issues };
      }
    };

    const detectDataFormat = (data) => {
      try {
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error('Invalid data array provided');
        }

        const sample = data[0];
        if (!sample || typeof sample !== 'object') {
          throw new Error('Invalid data structure - first item is not an object');
        }

        const keys = Object.keys(sample);
        
        const format = {
          hasQuestionAnswerPairs: keys.includes('question') && keys.includes('answer'),
          hasSentimentScore: keys.includes('sentiment_score'),
          hasSentiment: keys.includes('sentiment'),
          hasId: keys.includes('id'),
          questionKeys: keys.filter(k => !['id', 'sentiment', 'sentiment_score'].includes(k)),
          sentimentType: null,
          needsTransformation: false
        };

        if (format.hasSentimentScore) {
          const sentimentValues = data
            .map(d => d?.sentiment_score)
            .filter(v => v != null);
          format.sentimentType = analyzeSentimentRange(sentimentValues);
        } else if (format.hasSentiment) {
          const sentimentValues = data
            .map(d => d?.sentiment)
            .filter(v => v != null);
          format.sentimentType = analyzeSentimentRange(sentimentValues);
        }

        format.needsTransformation = format.hasQuestionAnswerPairs || 
                                   !format.hasSentimentScore || 
                                   (format.sentimentType?.needsNormalization);

        return format;
      } catch (error) {
        console.error('Data format detection error:', error);
        // Return default format for graceful degradation
        return {
          hasQuestionAnswerPairs: false,
          hasSentimentScore: false,
          hasSentiment: false,
          hasId: false,
          questionKeys: [],
          sentimentType: null,
          needsTransformation: true
        };
      }
    };

    const analyzeSentimentRange = (values) => {
      if (!Array.isArray(values) || values.length === 0) return null;
      
      try {
        const numericValues = values.filter(v => typeof v === 'number' && !isNaN(v));
        const stringValues = values.filter(v => typeof v === 'string');
        
        if (stringValues.length > 0) {
          const uniqueStrings = [...new Set(stringValues.map(v => v.toLowerCase()))];
          return {
            type: 'categorical',
            values: uniqueStrings,
            needsNormalization: true,
            suggested: 'Convert to 0-1 numeric range'
          };
        }
        
        if (numericValues.length > 0) {
          const min = Math.min(...numericValues);
          const max = Math.max(...numericValues);
          
          if (min >= -1 && max <= 1) {
            return { type: 'range_neg1_pos1', needsNormalization: max < 0 || min < 0 };
          } else if (min >= 0 && max <= 1) {
            return { type: 'range_0_1', needsNormalization: false };
          } else if (min >= 1 && max <= 5) {
            return { type: 'range_1_5', needsNormalization: true };
          } else if (min >= 0 && max <= 100) {
            return { type: 'range_0_100', needsNormalization: true };
          } else {
            return { type: 'custom_range', min, max, needsNormalization: true };
          }
        }
        
        return null;
      } catch (error) {
        console.error('Sentiment range analysis error:', error);
        return null;
      }
    };

    const normalizeDataFormat = (data, formatInfo, issues) => {
      try {
        if (!Array.isArray(data)) {
          throw new Error('Data must be an array');
        }

        let normalized = [...data];

        if (formatInfo?.hasQuestionAnswerPairs) {
          issues.push("✓ Converting question/answer pairs to direct properties");
          normalized = normalized.map((item, index) => {
            const newItem = { 
              id: item?.id || `resp_${String(index + 1).padStart(3, '0')}` 
            };
            
            if (item?.question && item?.answer) {
              newItem[item.question] = item.answer;
            }
            
            if (item?.sentiment_score != null) {
              newItem.sentiment_score = item.sentiment_score;
            } else if (item?.sentiment != null) {
              newItem.sentiment_score = normalizeSentimentValue(
                item.sentiment, 
                formatInfo.sentimentType
              );
            }
            
            return newItem;
          });
        } else {
          normalized = normalized.map((item, index) => ({
            ...item,
            id: item?.id || `resp_${String(index + 1).padStart(3, '0')}`
          }));
        }

        if (formatInfo?.sentimentType?.needsNormalization) {
          issues.push(`✓ Converting sentiment values from ${formatInfo.sentimentType.type} to 0-1 range`);
          normalized = normalized.map(item => ({
            ...item,
            sentiment_score: normalizeSentimentValue(
              item?.sentiment_score || item?.sentiment, 
              formatInfo.sentimentType
            )
          }));
        }

        if (!formatInfo?.hasSentimentScore && !formatInfo?.hasSentiment) {
          issues.push("⚠️ No sentiment data found - adding neutral sentiment scores");
          normalized = normalized.map(item => ({
            ...item,
            sentiment_score: 0.5
          }));
        }

        return normalized;
      } catch (error) {
        console.error('Data normalization error:', error);
        issues.push(`❌ Data normalization failed: ${error?.message || 'Unknown error'}`);
        return data; // Return original data as fallback
      }
    };

    const normalizeSentimentValue = (value, sentimentType) => {
      if (value == null) return 0.5;
      if (!sentimentType) return 0.5;
      
      try {
        switch (sentimentType.type) {
          case 'categorical':
            const lowerValue = String(value).toLowerCase();
            if (['positive', 'pos', 'good', 'happy', 'satisfied'].includes(lowerValue)) return 0.8;
            if (['negative', 'neg', 'bad', 'unhappy', 'dissatisfied'].includes(lowerValue)) return 0.2;
            return 0.5;
            
          case 'range_neg1_pos1':
            return (Number(value) + 1) / 2;
            
          case 'range_1_5':
            return (Number(value) - 1) / 4;
            
          case 'range_0_100':
            return Number(value) / 100;
            
          case 'custom_range':
            return (Number(value) - sentimentType.min) / (sentimentType.max - sentimentType.min);
            
          default:
            const numValue = Number(value);
            return isNaN(numValue) ? 0.5 : Math.max(0, Math.min(1, numValue));
        }
      } catch (error) {
        console.error('Sentiment value normalization error:', error);
        return 0.5; // Safe fallback
      }
    };

    const validateDataQuality = (data, issues) => {
      try {
        if (!Array.isArray(data) || data.length === 0) return;
        
        const sample = data[0];
        if (!sample || typeof sample !== 'object') return;
        
        const questionFields = Object.keys(sample).filter(k => !['id', 'sentiment_score'].includes(k));
        
        if (questionFields.length === 0) {
          issues.push("⚠️ No question fields detected - only ID and sentiment found");
        }
        
        const missingSentiment = data.filter(item => item?.sentiment_score == null).length;
        if (missingSentiment > 0) {
          issues.push(`⚠️ ${missingSentiment} responses missing sentiment scores`);
        }
        
        questionFields.forEach(question => {
          const missingAnswers = data.filter(item => 
            !item?.[question] || String(item[question]).trim() === ''
          ).length;
          if (missingAnswers > 0) {
            issues.push(`⚠️ ${missingAnswers} responses missing answer to: "${question.substring(0, 30)}..."`);
          }
        });
        
        if (!sample?.id) {
          issues.push("💡 Consider adding unique 'id' field for respondent tracking");
        }
      } catch (error) {
        console.error('Data quality validation error:', error);
        issues.push(`⚠️ Data quality check failed: ${error?.message || 'Unknown error'}`);
      }
    };

    // File Processing with enhanced error handling
    const handleFile = (file, datasetNumber) => {
      if (!file) {
        console.warn('No file provided to handleFile');
        return;
      }
      
      try {
        showProcessing(true);
        const reader = new FileReader();
        
        reader.onload = (e) => {
          try {
            const rawData = JSON.parse(e.target.result);
            const { data: processedData, issues } = validateAndTransformData(rawData, file.name);
            
            state.dataFormatIssues[`dataset${datasetNumber}`] = issues;
            
            if (processedData) {
              if (datasetNumber === 1) {
                state.dataset1 = processedData;
                showFileInfo(1, file.name, issues);
              } else {
                state.dataset2 = processedData;
                showFileInfo(2, file.name, issues);
              }
              
              if (issues.every(issue => issue.includes('✓') || issue.includes('💡'))) {
                state.dataFormatIssues[`dataset${datasetNumber}`].push('✅ Data successfully processed and ready for analysis');
              }
            } else {
              showFileError(datasetNumber, file.name, issues);
            }
            
            updateQuestionSelect();
            updateViews();
            
          } catch (parseError) {
            console.error('JSON parsing error:', parseError);
            const errorIssues = [`❌ JSON parsing error: ${parseError?.message || 'Invalid JSON format'}`];
            state.dataFormatIssues[`dataset${datasetNumber}`] = errorIssues;
            showFileError(datasetNumber, file.name, errorIssues);
          } finally {
            showProcessing(false);
          }
        };
        
        reader.onerror = (error) => {
          console.error('File reading error:', error);
          const errorIssues = [`❌ File reading error: ${error?.message || 'Could not read file'}`];
          state.dataFormatIssues[`dataset${datasetNumber}`] = errorIssues;
          showFileError(datasetNumber, file.name, errorIssues);
          showProcessing(false);
        };
        
        reader.readAsText(file);
        
      } catch (error) {
        console.error('File handling error:', error);
        const errorIssues = [`❌ File handling error: ${error?.message || 'Unknown error'}`];
        state.dataFormatIssues[`dataset${datasetNumber}`] = errorIssues;
        showFileError(datasetNumber, file.name, errorIssues);
        showProcessing(false);
      }
    };

    // UI Updates with enhanced error handling
    const showFileInfo = (datasetNumber, filename, issues) => {
      try {
        const infoEl = elements[`file${datasetNumber}Info`];
        const nameEl = elements[`file${datasetNumber}Name`];
        const statusEl = elements[`file${datasetNumber}Status`];
        
        if (!infoEl || !nameEl || !statusEl) {
          console.error(`Missing DOM elements for dataset ${datasetNumber}`);
          return;
        }
        
        nameEl.textContent = filename || 'Unknown file';
        infoEl.classList.remove('hidden');
        
        // Show status with appropriate styling
        const hasErrors = issues.some(issue => issue.includes('❌'));
        const hasWarnings = issues.some(issue => issue.includes('⚠️'));
        const successCount = issues.filter(issue => issue.includes('✅') || issue.includes('✓')).length;
        const warningCount = issues.filter(issue => issue.includes('⚠️')).length;
        
        if (hasErrors) {
          statusEl.className = 'mt-2 text-xs status-error';
          const errorMsg = issues.find(issue => issue.includes('❌')) || 'Processing failed';
          statusEl.textContent = errorMsg.replace('❌ ', '');
        } else if (hasWarnings) {
          statusEl.className = 'mt-2 text-xs status-warning';
          statusEl.textContent = `Processed with ${warningCount} warning${warningCount !== 1 ? 's' : ''}`;
        } else {
          statusEl.className = 'mt-2 text-xs status-success';
          statusEl.textContent = successCount > 0 ? 
            `Successfully processed (${successCount} transformation${successCount !== 1 ? 's' : ''})` : 
            'Successfully processed and ready';
        }
        
        // Add tooltip with all processing details
        if (issues.length > 0) {
          statusEl.title = issues.join('\n');
        }
      } catch (error) {
        console.error('Error showing file info:', error);
      }
    };

    const showFileError = (datasetNumber, filename, issues) => {
      try {
        const infoEl = elements[`file${datasetNumber}Info`];
        const nameEl = elements[`file${datasetNumber}Name`];
        const statusEl = elements[`file${datasetNumber}Status`];
        
        if (!infoEl || !nameEl || !statusEl) {
          console.error(`Missing DOM elements for dataset ${datasetNumber}`);
          return;
        }
        
        nameEl.textContent = filename || 'Unknown file';
        statusEl.className = 'mt-2 text-xs status-error';
        
        // Show the first (most important) error message
        const primaryError = issues.find(issue => issue.includes('❌')) || issues[0] || 'Processing failed';
        statusEl.textContent = primaryError.replace('❌ ', ''); // Remove emoji for cleaner display
        
        // Add a tooltip or expanded view for multiple errors
        if (issues.length > 1) {
          statusEl.title = issues.join('\n'); // Show all errors on hover
          statusEl.textContent += ` (+${issues.length - 1} more)`;
        }
        
        infoEl.classList.remove('hidden');
      } catch (error) {
        console.error('Error showing file error:', error);
      }
    };

    const showProcessing = (show) => {
      try {
        state.isProcessing = show;
        
        if (elements.loadingState) {
          elements.loadingState.classList.toggle('hidden', !show);
        }
        
        if (elements.emptyState) {
          elements.emptyState.classList.toggle('hidden', show || hasData());
        }
        
        if (elements.uploadStatus) {
          if (show) {
            elements.uploadStatus.classList.remove('hidden');
          } else {
            elements.uploadStatus.classList.add('hidden');
          }
        }
      } catch (error) {
        console.error('Error updating processing state:', error);
      }
    };

    const hasData = () => {
      return Boolean(state.dataset1 || state.dataset2);
    };

    function updateQuestionSelect() {
      const select = elements.questionSelect;
      select.innerHTML = '<option value="">-- Select Question --</option>';
      
      const getQuestions = (ds) => ds && ds.length > 0 ? 
        Object.keys(ds[0]).filter(q => q !== 'id' && q !== 'sentiment_score') : [];
      
      const questions1 = getQuestions(state.dataset1);
      const questions2 = getQuestions(state.dataset2);
      
      let commonQuestions = [];
      
      if (state.dataset1 && state.dataset2) {
        commonQuestions = questions1.filter(q => questions2.includes(q));
      } else if (state.dataset1) {
        commonQuestions = questions1;
      } else if (state.dataset2) {
        commonQuestions = questions2;
      }
      
      if (commonQuestions.length > 0) {
        commonQuestions.forEach(q => {
          const option = document.createElement('option');
          option.value = q;
          // Show full text in dropdown options - no truncation
          option.textContent = q;
          select.appendChild(option);
        });
        select.disabled = false;
        
        // Auto-select first question if none selected
        if (!state.selectedQuestion && commonQuestions.length > 0) {
          state.selectedQuestion = commonQuestions[0];
          select.value = state.selectedQuestion;
        }
      } else {
        select.innerHTML = `<option value="">${hasData() ? "No common questions found" : "Upload datasets to see questions"}</option>`;
        select.disabled = true;
        state.selectedQuestion = null;
      }
    }

    function updateViews() {
      if (!hasData()) {
        elements.emptyState.classList.remove('hidden');
        elements.viewSlider.classList.add('hidden');
        return;
      }
      
      elements.emptyState.classList.add('hidden');
      elements.viewSlider.classList.remove('hidden');
      
      // Render all views
      renderAllViews();
      
      // Use CSS-only scrolling - no complex event listeners needed
      scrollToCurrentView();
      
      // Add simple scroll detection for navigation updates
      setTimeout(() => {
        setupScrollDetection();
      }, 100);
    }

    function setupScrollDetection() {
      const slider = document.getElementById('view-slider');
      if (!slider) return;
      
      // Remove any existing listener first
      slider.removeEventListener('scroll', handleScrollDetection);
      
      // Add simple scroll detection that only updates navigation
      slider.addEventListener('scroll', handleScrollDetection, { passive: true });
    }

    function handleScrollDetection(e) {
      // Simple debounced scroll detection - faster response for better UX
      clearTimeout(state.scrollTimeout);
      state.scrollTimeout = setTimeout(() => {
        updateCurrentViewFromScroll();
      }, 50); // Reduced from 100ms to 50ms for more responsive updates
    }

    function updateCurrentViewFromScroll() {
      const slider = elements.viewSlider;
      if (!slider) return;
      
      const containerWidth = slider.offsetWidth;
      const scrollLeft = slider.scrollLeft;
      
      // More accurate view detection with small tolerance for edge cases
      const scrollPercent = scrollLeft / (slider.scrollWidth - containerWidth);
      let viewIndex;
      
      if (scrollPercent <= 0.1) {
        viewIndex = 0; // First view
      } else if (scrollPercent >= 0.9) {
        viewIndex = 2; // Last view
      } else {
        viewIndex = Math.round(scrollLeft / containerWidth);
      }
      
      const views = ['responses', 'sentiment', 'overlap'];
      const newView = views[Math.max(0, Math.min(viewIndex, views.length - 1))];
      
      // Only update if view actually changed
      if (newView && newView !== state.currentView) {
        state.currentView = newView;
        updateNavigationIndicators();
      }
    }

    function scrollToCurrentView() {
      const slider = elements.viewSlider;
      if (!slider) return;
      
      const views = ['responses', 'sentiment', 'overlap'];
      const currentIndex = views.indexOf(state.currentView);
      const scrollLeft = currentIndex * slider.offsetWidth;
      
      // Simple CSS scroll - let the browser handle it
      slider.scrollTo({
        left: scrollLeft,
        behavior: 'smooth'
      });
    }

    function setupSliderEventListeners() {
      // No longer needed - using pure CSS scrolling
      ;
    }

    function renderAllViews() {
      // Render responses view
      if (state.selectedQuestion) {
        const responsesHtml = `
          <div class="p-6">
            <h3 class="text-lg font-semibold text-slate-900 dark:text-white mb-4">Response Distributions</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              ${renderDatasetResponses(state.dataset1, 'Dataset A', 'primary')}
              ${renderDatasetResponses(state.dataset2, 'Dataset B', 'accent1')}
            </div>
          </div>
        `;
        elements.responsesView.innerHTML = responsesHtml;
        
        // Setup synchronized scrolling after DOM update
        setTimeout(() => {
          setupSynchronizedScrolling();
        }, 100);
      } else {
        elements.responsesView.innerHTML = getPlaceholderHtml('Select a question to compare response distributions');
      }

      // Render sentiment view
      const sentiment1 = calculateAverageSentiment(state.dataset1);
      const sentiment2 = calculateAverageSentiment(state.dataset2);
      
      const sentimentHtml = `
        <div class="p-6">
          <h3 class="text-lg font-semibold text-slate-900 dark:text-white mb-6">Sentiment Analysis</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            ${renderSentimentMeter(sentiment1, 'Dataset A', 'primary', state.dataset1)}
            ${renderSentimentMeter(sentiment2, 'Dataset B', 'accent1', state.dataset2)}
          </div>
        </div>
      `;
      elements.sentimentView.innerHTML = sentimentHtml;
      
      // Draw sentiment meters after DOM update
      setTimeout(() => {
        if (state.dataset1) drawSentimentMeter('sentiment-meter-1', sentiment1, '#3b82f6');
        if (state.dataset2) drawSentimentMeter('sentiment-meter-2', sentiment2, '#f59e0b');
      }, 50);

      // Render overlap view
      if (state.selectedQuestion && state.dataset1 && state.dataset2) {
        const overlap = calculateOverlap();
        const overlapHtml = `
          <div class="p-6">
            <h3 class="text-lg font-semibold text-slate-900 dark:text-white mb-6">Response Overlap Analysis</h3>
            <div class="text-center mb-6">
              <p class="text-sm text-slate-600 dark:text-slate-400 mb-4">
                Question: "<span class="font-medium">${state.selectedQuestion}</span>"
              </p>
            </div>
            
            <!-- Venn Diagram Container -->
            <div class="bg-slate-50 dark:bg-surface-800 p-6 mb-6">
              <div id="venn-diagram-container" class="w-full flex justify-center">
                <div id="venn-diagram" style="width: 100%; height: 300px;"></div>
              </div>
            </div>
            
            <!-- Summary Statistics -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <div class="bg-primary-50 dark:bg-primary-950 p-4 text-center">
                <div class="text-2xl font-bold text-primary-600 dark:text-primary-400">${overlap.onlyA}</div>
                <div class="text-sm text-primary-700 dark:text-primary-300">Only Dataset A</div>
              </div>
              <div class="bg-accent1-50 dark:bg-accent1-950 p-4 text-center">
                <div class="text-2xl font-bold text-accent1-600 dark:text-accent1-400">${overlap.both}</div>
                <div class="text-sm text-accent1-700 dark:text-accent1-300">Common Responses</div>
              </div>
              <div class="bg-accent2-50 dark:bg-accent2-950 p-4 text-center">
                <div class="text-2xl font-bold text-accent2-600 dark:text-accent2-400">${overlap.onlyB}</div>
                <div class="text-sm text-accent2-700 dark:text-accent2-300">Only Dataset B</div>
              </div>
            </div>
            
            ${overlap.commonAnswers.length > 0 ? `
              <div class="bg-slate-50 dark:bg-surface-800 p-4">
                <h4 class="font-medium text-slate-700 dark:text-slate-300 mb-3">Common Response Values</h4>
                <div class="grid grid-cols-1 gap-2 max-h-40 overflow-y-auto custom-scrollbar">
                  ${overlap.commonAnswers.slice(0, 10).map(answer => `
                    <div class="text-sm text-slate-600 dark:text-slate-400 bg-white dark:bg-surface-900 px-3 py-2">
                      "${answer.length > 80 ? answer.substring(0, 80) + '...' : answer}"
                    </div>
                  `).join('')}
                  ${overlap.commonAnswers.length > 10 ? `
                    <div class="text-xs text-slate-500 dark:text-slate-400 text-center py-2">
                      ... and ${overlap.commonAnswers.length - 10} more
                    </div>
                  ` : ''}
                </div>
              </div>
            ` : `
              <div class="bg-slate-50 dark:bg-surface-800 p-4 text-center">
                <p class="text-sm text-slate-600 dark:text-slate-400">No common response values found</p>
              </div>
            `}
          </div>
        `;
        elements.overlapView.innerHTML = overlapHtml;
        
        // Create Venn diagram
        setTimeout(() => {
          createVennDiagram(overlap);
        }, 50);
      } else {
        elements.overlapView.innerHTML = getPlaceholderHtml('Load both datasets and select a question to see response overlaps');
      }
    }

    // Synchronized Scrolling Implementation
    function setupSynchronizedScrolling() {
      const containers = document.querySelectorAll('.sync-scroll-container');
      if (containers.length < 2) return;
      
      // Setup scroll synchronization
      containers.forEach(container => {
        container.addEventListener('scroll', (e) => {
          const scrollTop = e.target.scrollTop;
          const otherContainers = Array.from(containers).filter(c => c !== e.target);
          
          otherContainers.forEach(other => {
            if (Math.abs(other.scrollTop - scrollTop) > 5) { // Avoid infinite loops
              other.scrollTop = scrollTop;
            }
          });
        });
        
        // Setup drag-to-scroll functionality
        setupDragToScroll(container);
      });
    }
    
    // Drag-to-scroll implementation
    function setupDragToScroll(container) {
      let isDragging = false;
      let startY = 0;
      let startScrollTop = 0;
      
      // Mouse events
      container.addEventListener('mousedown', (e) => {
        isDragging = true;
        startY = e.clientY;
        startScrollTop = container.scrollTop;
        container.classList.add('dragging');
        
        // Prevent text selection during drag
        e.preventDefault();
        
        // Add document listeners for better drag handling
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      });
      
      function handleMouseMove(e) {
        if (!isDragging) return;
        
        const deltaY = startY - e.clientY;
        container.scrollTop = startScrollTop + deltaY;
        
        e.preventDefault();
      }
      
      function handleMouseUp(e) {
        if (isDragging) {
          isDragging = false;
          container.classList.remove('dragging');
          
          // Remove document listeners
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        }
      }
      
      // Touch events for mobile
      container.addEventListener('touchstart', (e) => {
        isDragging = true;
        startY = e.touches[0].clientY;
        startScrollTop = container.scrollTop;
        container.classList.add('dragging');
      }, { passive: true });
      
      container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        
        const deltaY = startY - e.touches[0].clientY;
        container.scrollTop = startScrollTop + deltaY;
      }, { passive: true });
      
      container.addEventListener('touchend', (e) => {
        if (isDragging) {
          isDragging = false;
          container.classList.remove('dragging');
        }
      }, { passive: true });
      
      // Handle mouse leave to stop dragging
      container.addEventListener('mouseleave', (e) => {
        if (isDragging) {
          isDragging = false;
          container.classList.remove('dragging');
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        }
      });
    }

    function getPlaceholderHtml(message) {
      return `
        <div class="flex flex-col items-center justify-center h-96 text-center p-8">
          <div class="w-16 h-16 bg-slate-100 dark:bg-surface-800 rounded-full flex items-center justify-center mb-4">
            <svg class="w-8 h-8 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
          <p class="text-slate-600 dark:text-slate-400 max-w-sm">${message}</p>
        </div>
      `;
    }

    // View Rendering Functions
    function renderDatasetResponses(dataset, title, colorTheme) {
      if (!dataset) {
        return `
          <div class="bg-slate-50 dark:bg-surface-800 p-4">
            <h4 class="font-medium text-slate-700 dark:text-slate-300 mb-2">${title}</h4>
            <p class="text-sm text-slate-500 dark:text-slate-400">No data loaded</p>
          </div>
        `;
      }
      
      const responses = dataset.map(item => ({
        id: item.id,
        answer: item[state.selectedQuestion] || 'No response',
        sentiment: item.sentiment_score || 0
      }));
      
      const colorClass = colorTheme === 'primary' ? 'border-l-primary-500' : 'border-l-accent1-600';
      const bgClass = colorTheme === 'primary' ? 'bg-primary-50 dark:bg-primary-950' : 'bg-accent1-100 dark:bg-accent1-900';
      
      return `
        <div class="bg-slate-50 dark:bg-surface-800 p-4">
          <h4 class="font-medium text-slate-700 dark:text-slate-300 mb-4">${title} (${responses.length} responses)</h4>
          <div class="sync-scroll-container custom-scrollbar" data-dataset="${colorTheme}">
            ${responses.map((response, index) => {
              const sentimentColor = response.sentiment >= 0.7 ? 'text-accent1-800 dark:text-accent1-300' : 
                                   response.sentiment >= 0.4 ? 'text-accent1-700 dark:text-accent1-400' : 
                                   'text-accent2-700 dark:text-accent2-400';
              return `
                <div class="sync-scroll-item ${bgClass} border-l-4 ${colorClass}" data-index="${index}">
                  <div class="flex-1">
                    <div class="flex items-center justify-between mb-1">
                      <span class="text-xs font-medium text-slate-600 dark:text-slate-400">${response.id}</span>
                      <span class="text-xs font-medium ${sentimentColor}">${(response.sentiment * 100).toFixed(0)}%</span>
                    </div>
                    <div class="text-sm text-slate-800 dark:text-slate-200">${response.answer.length > 100 ? response.answer.substring(0, 100) + '...' : response.answer}</div>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    function renderSentimentMeter(sentiment, title, colorTheme, dataset) {
      if (!dataset) {
        return `
          <div class="text-center">
            <h4 class="font-medium text-slate-700 dark:text-slate-300 mb-4">${title}</h4>
            <div class="text-sm text-slate-500 dark:text-slate-400">No data loaded</div>
          </div>
        `;
      }
      
      if (sentiment === null) {
        return `
          <div class="text-center">
            <h4 class="font-medium text-slate-700 dark:text-slate-300 mb-4">${title}</h4>
            <div class="text-sm text-slate-500 dark:text-slate-400">No sentiment data available</div>
          </div>
        `;
      }
      
      const percentage = Math.round(sentiment * 100);
      const meterNumber = title.includes('A') ? '1' : '2';
      
      // Determine sentiment label and color
      let sentimentLabel = 'Neutral';
      let sentimentColor = 'text-warning-600 dark:text-warning-400';
      
      if (sentiment >= 0.7) {
        sentimentLabel = 'Positive';
        sentimentColor = 'text-success-600 dark:text-success-400';
      } else if (sentiment >= 0.4) {
        sentimentLabel = 'Mixed';
        sentimentColor = 'text-warning-600 dark:text-warning-400';
      } else {
        sentimentLabel = 'Negative';
        sentimentColor = 'text-danger-600 dark:text-danger-400';
      }
      
      return `
        <div class="text-center">
          <h4 class="font-medium text-slate-700 dark:text-slate-300 mb-4">${title}</h4>
          <div class="relative w-32 h-32 mx-auto mb-4">
            <svg id="sentiment-meter-${meterNumber}" width="128" height="128" viewBox="0 0 128 128" class="transform -rotate-90">
              <!-- Meter will be drawn here -->
            </svg>
            <div class="absolute inset-0 flex items-center justify-center">
              <span class="text-2xl font-bold text-slate-900 dark:text-white">${percentage}%</span>
            </div>
          </div>
          <div class="space-y-1">
            <div class="text-lg font-semibold ${sentimentColor}">${sentimentLabel} Sentiment</div>
            <div class="text-sm text-slate-600 dark:text-slate-400">
              Average score: ${sentiment.toFixed(2)}/1.0
            </div>
            <div class="text-xs text-slate-500 dark:text-slate-400">
              Based on ${dataset.length} responses
            </div>
          </div>
        </div>
      `;
    }

    function drawSentimentMeter(elementId, sentiment, color) {
      const svg = document.getElementById(elementId);
      if (!svg) return;
      
      const radius = 50;
      const strokeWidth = 8;
      const normalizedRadius = radius - strokeWidth * 2;
      const circumference = normalizedRadius * 2 * Math.PI;
      const strokeDasharray = `${circumference} ${circumference}`;
      const strokeDashoffset = circumference - sentiment * circumference;
      
      svg.innerHTML = `
        <circle
          stroke="#e2e8f0"
          fill="transparent"
          stroke-width="${strokeWidth}"
          r="${normalizedRadius}"
          cx="64"
          cy="64"
        />
        <circle
          stroke="${color}"
          fill="transparent"
          stroke-width="${strokeWidth}"
          stroke-dasharray="${strokeDasharray}"
          stroke-dashoffset="${strokeDashoffset}"
          stroke-linecap="round"
          r="${normalizedRadius}"
          cx="64"
          cy="64"
          style="transition: stroke-dashoffset 0.8s ease-in-out"
        />
      `;
    }

    function createVennDiagram(overlap) {
      const container = document.getElementById('venn-diagram');
      if (!container) return;
      
      // Clear any existing diagram
      d3.select('#venn-diagram').selectAll('*').remove();
      
      // Calculate total responses for proper sizing
      const totalA = overlap.onlyA + overlap.both;
      const totalB = overlap.onlyB + overlap.both;
      const intersection = overlap.both;
      
      // Ensure we have meaningful data for the diagram
      if (totalA === 0 && totalB === 0) {
        container.innerHTML = '<div class="flex items-center justify-center h-full text-slate-500 dark:text-slate-400">No data to visualize</div>';
        return;
      }
      
      // Prepare data for venn.js (minimum size to ensure visibility)
      const minSize = 5;
      const sets = [
        { sets: ['A'], size: Math.max(totalA, minSize), label: `Dataset A (${totalA})` },
        { sets: ['B'], size: Math.max(totalB, minSize), label: `Dataset B (${totalB})` }
      ];
      
      // Only add intersection if it exists
      if (intersection > 0) {
        sets.push({ sets: ['A', 'B'], size: intersection, label: `Common (${intersection})` });
      }
      
      // Create the diagram
      const chart = venn.VennDiagram()
        .width(container.offsetWidth || 400)
        .height(300);
      
      const div = d3.select('#venn-diagram');
      div.datum(sets).call(chart);
      
      // Style the diagram
      div.selectAll('.venn-circle path')
        .style('fill-opacity', 0.3)
        .style('stroke-width', 2)
        .style('stroke-opacity', 0.8);
      
      // Color the sets
      div.selectAll('g')
        .filter(function(d) { return d.sets.length === 1; })
        .select('path')
        .style('fill', function(d) {
          return d.sets[0] === 'A' ? '#3b82f6' : '#f59e0b';
        })
        .style('stroke', function(d) {
          return d.sets[0] === 'A' ? '#2563eb' : '#d97706';
        });
      
      // Color the intersection
      div.selectAll('g')
        .filter(function(d) { return d.sets.length > 1; })
        .select('path')
        .style('fill', '#ef4444')
        .style('stroke', '#dc2626');
      
      // Add hover effects
      div.selectAll('g')
        .on('mouseover', function(d, i) {
          d3.select(this).select('path')
            .style('fill-opacity', 0.5)
            .style('stroke-width', 3);
        })
        .on('mouseout', function(d, i) {
          d3.select(this).select('path')
            .style('fill-opacity', 0.3)
            .style('stroke-width', 2);
        });
      
      // Style text labels
      div.selectAll('text')
        .style('fill', function() {
          return document.documentElement.dataset.theme === 'dark' ? '#f1f5f9' : '#334155';
        })
        .style('font-size', '12px')
        .style('font-weight', '500')
        .style('text-anchor', 'middle');
      
      // Handle responsive sizing
      const resizeObserver = new ResizeObserver(entries => {
        const newWidth = entries[0].contentRect.width;
        if (newWidth > 0) {
          chart.width(newWidth);
          div.datum(sets).call(chart);
        }
      });
      
      resizeObserver.observe(container);
    }

    function calculateOverlap() {
      const answers1 = new Set();
      const answers2 = new Set();
      
      state.dataset1.forEach(item => {
        if (item[state.selectedQuestion]) {
          answers1.add(String(item[state.selectedQuestion]));
        }
      });
      
      state.dataset2.forEach(item => {
        if (item[state.selectedQuestion]) {
          answers2.add(String(item[state.selectedQuestion]));
        }
      });
      
      const commonAnswers = [...answers1].filter(answer => answers2.has(answer));
      const onlyA = answers1.size - commonAnswers.length;
      const onlyB = answers2.size - commonAnswers.length;
      
      return {
        onlyA,
        onlyB,
        both: commonAnswers.length,
        commonAnswers
      };
    }

    function calculateAverageSentiment(dataset) {
      if (!dataset || dataset.length === 0) return null;
      
      const scores = dataset
        .map(item => item.sentiment_score)
        .filter(score => typeof score === 'number' && score >= 0 && score <= 1);
      
      if (scores.length === 0) return null;
      
      return scores.reduce((sum, score) => sum + score, 0) / scores.length;
    }

    // Navigation
    function switchView(viewName) {
      if (state.currentView === viewName) return;
      
      state.currentView = viewName;
      
      // Update all navigation indicators
      updateNavigationIndicators();
      
      // Simply scroll to the new view - CSS handles the rest
      scrollToCurrentView();
    }

    // Touch/Swipe Navigation - simple mobile support only
    function handleTouchStart(e) {
      state.touchStart = e.touches[0].clientX;
    }

    function handleTouchEnd(e) {
      if (!state.touchStart) return;
      
      const touchEnd = e.changedTouches[0].clientX;
      const diff = state.touchStart - touchEnd;
      const threshold = 50;
      
      if (Math.abs(diff) > threshold) {
        const views = ['responses', 'sentiment', 'overlap'];
        const currentIndex = views.indexOf(state.currentView);
        
        if (diff > 0 && currentIndex < views.length - 1) {
          // Swipe left - next view
          switchView(views[currentIndex + 1]);
        } else if (diff < 0 && currentIndex > 0) {
          // Swipe right - previous view
          switchView(views[currentIndex - 1]);
        }
      }
      
      state.touchStart = null;
    }

    // Smooth Drag Navigation for Slider
    function handleDragStart(e) {
      state.isDragging = true;
      state.dragStart = e.clientX;
      state.initialScrollLeft = elements.viewSlider ? document.getElementById('view-slider').scrollLeft : 0;
      
      const slider = document.getElementById('view-slider');
      if (slider) {
        slider.classList.add('manual-scroll'); // Disable snap during drag
        slider.style.scrollBehavior = 'auto';
        
        // Add mouse move listener to document for better drag handling
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
      }
      
      e.preventDefault();
    }

    function handleDragMove(e) {
      if (!state.isDragging || !state.dragStart) return;
      
      const slider = document.getElementById('view-slider');
      if (!slider) return;
      
      const diff = state.dragStart - e.clientX;
      slider.scrollLeft = state.initialScrollLeft + diff;
      
      e.preventDefault();
    }

    function handleDragEnd(e) {
      if (state.isDragging) {
        state.isDragging = false;
        state.dragStart = null;
        state.initialScrollLeft = 0;
        
        const slider = document.getElementById('view-slider');
        if (slider) {
          slider.classList.remove('manual-scroll'); // Re-enable snap
          slider.style.scrollBehavior = 'smooth';
        }
        
        // Remove document listeners
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
        
        // Smooth snap to nearest view
        setTimeout(() => {
          smoothSnapToNearestView();
        }, 100);
      }
    }

    // Smooth Touch Navigation for Slider
    function handleSliderTouchStart(e) {
      state.touchStart = e.touches[0].clientX;
      const slider = elements.viewSlider;
      if (slider) {
        slider.classList.add('manual-scroll'); // Disable snap during touch
        slider.style.scrollBehavior = 'auto';
      }
    }

    function handleSliderTouchEnd(e) {
      if (state.touchStart) {
        const slider = elements.viewSlider;
        if (slider) {
          slider.classList.remove('manual-scroll'); // Re-enable snap
          slider.style.scrollBehavior = 'smooth';
        }
        state.touchStart = null;
        
        // Smooth snap to nearest view after touch ends
        setTimeout(() => {
          smoothSnapToNearestView();
        }, 150);
      }
    }

    // Improved Scroll Event Handler with reduced jank
    function handleSliderScroll(e) {
      // Much shorter debounce for smoother response
      clearTimeout(state.scrollTimeout);
      state.scrollTimeout = setTimeout(() => {
        updateCurrentViewFromScroll();
      }, 50); // Reduced from 150ms to 50ms
    }

    function smoothSnapToNearestView() {
      const slider = elements.viewSlider;
      if (!slider) return;
      
      const containerWidth = slider.offsetWidth;
      const scrollLeft = slider.scrollLeft;
      const viewIndex = Math.round(scrollLeft / containerWidth);
      
      const views = ['responses', 'sentiment', 'overlap'];
      const targetView = views[Math.max(0, Math.min(viewIndex, views.length - 1))];
      const targetScrollLeft = viewIndex * containerWidth;
      
      // Only snap if we're not already very close to the target
      if (Math.abs(scrollLeft - targetScrollLeft) > 10) {
        slider.scrollTo({
          left: targetScrollLeft,
          behavior: 'smooth'
        });
      }
      
      // Update view state if changed
      if (targetView !== state.currentView) {
        state.currentView = targetView;
        updateNavigationIndicators();
      }
    }

    // Accessibility Utilities
    function announceToScreenReader(message) {
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.setAttribute('aria-atomic', 'true');
      announcement.className = 'sr-only';
      announcement.textContent = message;
      
      document.body.appendChild(announcement);
      
      // Remove after announcement
      setTimeout(() => {
        document.body.removeChild(announcement);
      }, 1000);
    }
    
    function trapFocus(element) {
      const focusableElements = element.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];
      
      element.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
          if (e.shiftKey) {
            if (document.activeElement === firstFocusable) {
              e.preventDefault();
              lastFocusable.focus();
            }
          } else {
            if (document.activeElement === lastFocusable) {
              e.preventDefault();
              firstFocusable.focus();
            }
          }
        }
      });
    }

    function updateNavigationIndicators() {
      // View title mapping
      const viewTitles = {
        'responses': 'Response Distributions',
        'sentiment': 'Sentiment Analysis', 
        'overlap': 'Response Overlap'
      };
      
      // Update desktop navigation tabs with ARIA states
      elements.navTabs.forEach(tab => {
        const isActive = tab.dataset.view === state.currentView;
        tab.classList.toggle('bg-white', isActive);
        tab.classList.toggle('dark:bg-surface-800', isActive);
        tab.classList.toggle('text-slate-900', isActive);
        tab.classList.toggle('dark:text-white', isActive);
        tab.classList.toggle('shadow-sm', isActive);
        tab.classList.toggle('text-slate-600', !isActive);
        tab.classList.toggle('dark:text-slate-400', !isActive);
        
        // Update ARIA states
        tab.setAttribute('aria-selected', isActive.toString());
        tab.setAttribute('tabindex', isActive ? '0' : '-1');
      });
      
      // Update mobile navigation dots with ARIA states
      elements.navDots.forEach(dot => {
        const isActive = dot.dataset.view === state.currentView;
        dot.classList.toggle('bg-primary-500', isActive);
        dot.classList.toggle('bg-slate-300', !isActive);
        dot.classList.toggle('dark:bg-slate-600', !isActive);
        
        // Update ARIA states
        dot.setAttribute('aria-selected', isActive.toString());
        dot.setAttribute('tabindex', isActive ? '0' : '-1');
      });
      
      // Update mobile navigation elements
      if (elements.currentViewTitle) {
        elements.currentViewTitle.textContent = viewTitles[state.currentView] || state.currentView;
      }
      
      if (elements.mobileViewSelect) {
        elements.mobileViewSelect.value = state.currentView;
      }
      
      // Update mobile prev/next button states
      const views = ['responses', 'sentiment', 'overlap'];
      const currentIndex = views.indexOf(state.currentView);
      
      if (elements.mobilePrev) {
        elements.mobilePrev.disabled = currentIndex === 0;
        elements.mobilePrev.setAttribute('aria-disabled', (currentIndex === 0).toString());
        elements.mobilePrev.title = currentIndex > 0 ? `Previous: ${viewTitles[views[currentIndex - 1]]}` : 'No previous view';
      }
      
      if (elements.mobileNext) {
        elements.mobileNext.disabled = currentIndex === views.length - 1;
        elements.mobileNext.setAttribute('aria-disabled', (currentIndex === views.length - 1).toString());
        elements.mobileNext.title = currentIndex < views.length - 1 ? `Next: ${viewTitles[views[currentIndex + 1]]}` : 'No next view';
      }
      
      // Announce view change to screen readers
      announceToScreenReader(`Switched to ${viewTitles[state.currentView]} view`);
    }

    // Theme Management
    function initializeTheme() {
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const isDark = savedTheme ? savedTheme === 'dark' : prefersDark;
      
      document.documentElement.dataset.theme = isDark ? 'dark' : 'light';
      document.documentElement.classList.toggle('dark', isDark);
      
      // Update theme toggle aria-pressed state
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.setAttribute('aria-pressed', isDark.toString());
      }
    }

    function toggleTheme() {
      const isDark = document.documentElement.dataset.theme === 'dark';
      const newTheme = isDark ? 'light' : 'dark';
      
      document.documentElement.dataset.theme = newTheme;
      document.documentElement.classList.toggle('dark', newTheme === 'dark');
      localStorage.setItem('theme', newTheme);
      
      // Update aria-pressed state
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.setAttribute('aria-pressed', (newTheme === 'dark').toString());
      }
      
      // Announce theme change to screen readers
      announceToScreenReader(`Switched to ${newTheme} mode`);
    }

    // Help Modal
    function showHelp() {
      elements.helpModal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
      
      // Set focus to close button and trap focus within modal
      const closeButton = document.getElementById('help-close');
      if (closeButton) {
        closeButton.focus();
        trapFocus(elements.helpModal);
      }
      
      // Announce modal opening to screen readers
      announceToScreenReader('Help dialog opened');
    }

    function hideHelp() {
      elements.helpModal.classList.add('hidden');
      document.body.style.overflow = '';
      
      // Return focus to help button
      const helpButton = document.getElementById('help-btn');
      if (helpButton) {
        helpButton.focus();
      }
      
      // Announce modal closing to screen readers
      announceToScreenReader('Help dialog closed');
    }

    // Event Listeners with enhanced error handling
    const setupEventListeners = () => {
      try {
        // Validate DOM elements before attaching listeners
        validateDOMElements();

        // File inputs with error handling
        elements.file1?.addEventListener('change', (e) => {
          if (e.target.files?.[0]) handleFile(e.target.files[0], 1);
        });
        
        elements.file2?.addEventListener('change', (e) => {
          if (e.target.files?.[0]) handleFile(e.target.files[0], 2);
        });
        
        // File removal with safety checks
        elements.file1Remove?.addEventListener('click', () => {
          try {
            state.dataset1 = null;
            if (elements.file1) elements.file1.value = '';
            elements.file1Info?.classList.add('hidden');
            updateQuestionSelect();
            updateViews();
          } catch (error) {
            console.error('Error removing file 1:', error);
          }
        });
        
        elements.file2Remove?.addEventListener('click', () => {
          try {
            state.dataset2 = null;
            if (elements.file2) elements.file2.value = '';
            elements.file2Info?.classList.add('hidden');
            updateQuestionSelect();
            updateViews();
          } catch (error) {
            console.error('Error removing file 2:', error);
          }
        });
        
        // Question selection with validation
        elements.questionSelect?.addEventListener('change', (e) => {
          try {
            state.selectedQuestion = e.target.value;
            updateViews();
          } catch (error) {
            console.error('Error updating selected question:', error);
          }
        });
        
        // Navigation with error boundaries
        elements.navTabs?.forEach(tab => {
          tab.addEventListener('click', (e) => {
            try {
              e.preventDefault();
              const viewName = tab.dataset.view;
              if (viewName) switchView(viewName);
            } catch (error) {
              console.error('Error switching view via tab:', error);
            }
          });
        });
        
        elements.navDots?.forEach(dot => {
          dot.addEventListener('click', (e) => {
            try {
              e.preventDefault();
              const viewName = dot.dataset.view;
              if (viewName) switchView(viewName);
            } catch (error) {
              console.error('Error switching view via dot:', error);
            }
          });
        });
        
        // Mobile navigation with safety checks
        elements.mobileViewSelect?.addEventListener('change', (e) => {
          try {
            switchView(e.target.value);
          } catch (error) {
            console.error('Error switching view via mobile select:', error);
          }
        });
        
        elements.mobilePrev?.addEventListener('click', () => {
          try {
            const views = ['responses', 'sentiment', 'overlap'];
            const currentIndex = views.indexOf(state.currentView);
            if (currentIndex > 0) {
              switchView(views[currentIndex - 1]);
            }
          } catch (error) {
            console.error('Error navigating to previous view:', error);
          }
        });
        
        elements.mobileNext?.addEventListener('click', () => {
          try {
            const views = ['responses', 'sentiment', 'overlap'];
            const currentIndex = views.indexOf(state.currentView);
            if (currentIndex < views.length - 1) {
              switchView(views[currentIndex + 1]);
            }
          } catch (error) {
            console.error('Error navigating to next view:', error);
          }
        });
        
        
        // Theme toggle with validation
        elements.themeToggle?.addEventListener('click', () => {
          try {
            toggleTheme();
          } catch (error) {
            console.error('Error toggling theme:', error);
          }
        });
        
        // Help modal with safety checks
        elements.helpBtn?.addEventListener('click', (e) => {
          try {
            e.preventDefault();
            showHelp();
          } catch (error) {
            console.error('Error showing help:', error);
          }
        });
        
        elements.helpClose?.addEventListener('click', (e) => {
          try {
            e.preventDefault();
            hideHelp();
          } catch (error) {
            console.error('Error hiding help:', error);
          }
        });
        
        elements.helpModal?.addEventListener('click', (e) => {
          try {
            if (e.target === elements.helpModal) hideHelp();
          } catch (error) {
            console.error('Error handling modal click:', error);
          }
        });
        
        // Keyboard shortcuts with modern event handling
        document.addEventListener('keydown', (e) => {
          try {
            // Help modal handling
            if (e.key === 'Escape' && !elements.helpModal?.classList.contains('hidden')) {
              hideHelp();
              return;
            }
            
            // Skip links activation
            if (e.key === 'Enter' || e.key === ' ') {
              const target = e.target;
              if (target.classList.contains('skip-link')) {
                e.preventDefault();
                const href = target.getAttribute('href');
                const targetElement = document.querySelector(href);
                if (targetElement) {
                  targetElement.focus();
                }
                return;
              }
            }
            
            // Tab navigation for analysis views (when not in modal)
            if (elements.helpModal?.classList.contains('hidden')) {
              // Arrow key navigation for tabs
              if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const focusedElement = document.activeElement;
                if (focusedElement.classList.contains('nav-tab') || focusedElement.classList.contains('nav-dot')) {
                  e.preventDefault();
                  const views = ['responses', 'sentiment', 'overlap'];
                  const currentIndex = views.indexOf(state.currentView);
                  let newIndex;
                  
                  if (e.key === 'ArrowLeft') {
                    newIndex = currentIndex > 0 ? currentIndex - 1 : views.length - 1;
                  } else {
                    newIndex = currentIndex < views.length - 1 ? currentIndex + 1 : 0;
                  }
                  
                  switchView(views[newIndex]);
                  
                  // Focus the corresponding tab
                  const newTab = document.querySelector(`[data-view="${views[newIndex]}"].nav-tab, [data-view="${views[newIndex]}"].nav-dot`);
                  if (newTab) {
                    newTab.focus();
                  }
                  return;
                }
              }
              
              // Global keyboard shortcuts
              if (e.altKey) {
                switch (e.key) {
                  case '1':
                    e.preventDefault();
                    switchView('responses');
                    break;
                  case '2':
                    e.preventDefault();
                    switchView('sentiment');
                    break;
                  case '3':
                    e.preventDefault();
                    switchView('overlap');
                    break;
                  case 'h':
                    e.preventDefault();
                    showHelp();
                    break;
                  case 't':
                    e.preventDefault();
                    toggleTheme();
                    break;
                }
              }
            }
          } catch (error) {
            console.error('Error handling keyboard shortcut:', error);
          }
        });
        

        ;
        
      } catch (error) {
        console.error('Critical error setting up event listeners:', error);
        // Show user-friendly error message
        const errorMessage = document.createElement('div');
        errorMessage.className = 'fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50';
        errorMessage.textContent = 'Application initialization failed. Please refresh the page.';
        document.body.appendChild(errorMessage);
      }
    };

    // Initialize Application with comprehensive error handling
    const init = () => {
      try {
        ;
        
        // Initialize theme first (lowest risk)
        initializeTheme();
        
        // Set up event listeners (validates DOM)
        setupEventListeners();
        
        // Set up scroll detection for navigation updates
        setTimeout(() => {
          setupScrollDetection();
        }, 200);
        
        // Initialize view state
        switchView('responses');
        updateViews();
        
        ;
        
      } catch (error) {
        console.error('❌ Critical initialization error:', error);
        
        // Show fallback UI
        const fallbackHTML = `
          <div class="fixed inset-0 bg-red-50 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-lg shadow-lg max-w-md text-center">
              <h2 class="text-xl font-bold text-red-800 mb-4">Application Error</h2>
              <p class="text-red-600 mb-4">The application failed to initialize properly.</p>
              <button onclick="location.reload()" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                Reload Page
              </button>
            </div>
          </div>
        `;
        document.body.insertAdjacentHTML('beforeend', fallbackHTML);
      }
    };

    // Start the application when DOM is ready with modern pattern
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      // DOM already loaded
      init();
    }
  </script>
</body>
</html>